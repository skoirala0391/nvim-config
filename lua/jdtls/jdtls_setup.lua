local M = {}

local function jdtls_root()
  return vim.fs.root(0, { "mvnw", "gradlew", "pom.xml", "build.gradle", "settings.gradle", ".git" })
end

local function workspace_dir()
  local project_name = vim.fn.fnamemodify(vim.fn.getcwd(), ":p:h:t")
  local sep = package.config:sub(1, 1)
  return vim.fn.stdpath("data") .. sep .. "jdtls-workspace" .. sep .. project_name
end

local function jdtls_bundles()
  local bundles = {}

  local mason_path = vim.fn.stdpath("data") .. "/mason/packages"

  -- java-debug-adapter (1 jar)
  local debug_jar = vim.fn.glob(mason_path .. "/java-debug-adapter/extension/server/com.microsoft.java.debug.plugin-*.jar")
  if debug_jar ~= "" then
    table.insert(bundles, debug_jar)
  end

  -- java-test (multiple jars)
  local test_jars = vim.fn.glob(mason_path .. "/java-test/extension/server/*.jar", 1, 1)
  for _, jar in ipairs(test_jars) do
    table.insert(bundles, jar)
  end

  return bundles
end

local function current_fqcn()
  -- Best-effort: read package + class from current buffer
  local lines = vim.api.nvim_buf_get_lines(0, 0, math.min(80, vim.api.nvim_buf_line_count(0)), false)
  local pkg
  local cls

  for _, l in ipairs(lines) do
    if not pkg then
      pkg = l:match("^%s*package%s+([%w%.]+)%s*;")
    end
    if not cls then
      cls = l:match("^%s*public%s+class%s+([%w_]+)")
        or l:match("^%s*class%s+([%w_]+)")
    end
    if pkg and cls then break end
  end

  if not cls then return nil end
  if pkg then return pkg .. "." .. cls end
  return cls
end

local function pick_java_main_config_for_current_buffer()
  local ok_dap, dap = pcall(require, "dap")
  if not ok_dap then
    return nil, "nvim-dap not available"
  end

  -- Ensure main configs exist (generated by java-debug adapter)
  local ok = pcall(function()
    require("jdtls.dap").setup_dap_main_class_configs()
  end)
  if not ok then
    return nil, "Failed to generate main class debug configs (is java-debug-adapter bundle loaded?)"
  end

  local configs = dap.configurations.java or {}
  if vim.tbl_isempty(configs) then
    return nil, "dap.configurations.java is empty (no main configs generated)"
  end

  local fqcn = current_fqcn()
  if fqcn then
    for _, cfg in ipairs(configs) do
      -- java-debug configs typically have `mainClass`
      if cfg.mainClass == fqcn then
        return cfg
      end
      -- fallback matching (sometimes name contains the class)
      if cfg.name and cfg.name:find(fqcn, 1, true) then
        return cfg
      end
    end
  end

  -- No exact match: fall back to first config (still no picker)
  return configs[1]
end

local function java_keymaps(bufnr)
  local map = function(mode, lhs, rhs, desc)
    vim.keymap.set(mode, lhs, rhs, { buffer = bufnr, desc = desc })
  end
  -- Run main() (NO DEBUG, no picker)
  map("n", "<leader>jr", function()
    local cfg, err = pick_java_main_config_for_current_buffer()
    if not cfg then
      vim.notify(err or "Could not find a Java run config for this file", vim.log.levels.ERROR)
      return
    end

    local dap = require("dap")    
    
    pcall(vim.cmd, "DapReset")
    
    local run_cfg = vim.deepcopy(cfg)
    run_cfg.noDebug = true

    -- Make it visible + avoid buffer reuse issues
    dap.repl.open({}, "belowright 15split")

    pcall(function() require("dap").terminate() end)
    pcall(function() require("dap").close() end)
    dap.run(run_cfg)
  end, "Java: Run main()")
  -- Debug main() (with breakpoints, no picker)
  map("n", "<leader>jd", function()
    local cfg, err = pick_java_main_config_for_current_buffer()
    if not cfg then
      vim.notify(err or "Could not find a Java debug config for this file", vim.log.levels.ERROR)
      return
    end

    pcall(vim.cmd, "DapReset")
    require("dap").run(cfg)
  end, "Java: Debug main()")
  -- JUnit tests
  map("n", "<leader>tn", function()
    require("jdtls").test_nearest_method()
  end, "Java: Test nearest method")

  map("n", "<leader>tc", function()
    require("jdtls").test_class()
  end, "Java: Test class")

  map("n", "<leader>jg", function()
    vim.lsp.buf.code_action({ apply = false })
  end, "Java: Generate (getters/setters)")

  -- General DAP shortcuts (nice to have)
  map("n", "<F5>", function() require("dap").continue() end, "DAP: Continue")
  map("n", "<F10>", function() require("dap").step_over() end, "DAP: Step over")
  map("n", "<F11>", function() require("dap").step_into() end, "DAP: Step into")
  map("n", "<F12>", function() require("dap").step_out() end, "DAP: Step out")
  map("n", "<leader>db", function() require("dap").toggle_breakpoint() end, "DAP: Toggle breakpoint")
  map("n", "<leader>dB", function()
    require("dap").set_breakpoint(vim.fn.input("Breakpoint condition: "))
  end, "DAP: Conditional breakpoint")
  map("n", "<leader>du", function() require("dapui").toggle() end, "DAP UI: Toggle")
  map("n", "<leader>dx", function() require("dap").terminate() end, "DAP: Terminate")
end

function M.setup()
  local ok, jdtls = pcall(require, "jdtls")
  if not ok then
    return
  end

  local root_dir = jdtls_root()
  if not root_dir then
    -- Not in a Java project root; don't start jdtls.
    return
  end

  local config = {
    cmd = { "jdtls", "-data", workspace_dir() },
    root_dir = root_dir,

    capabilities = vim.tbl_deep_extend(
      "force",
      vim.lsp.protocol.make_client_capabilities(),
      {
        textDocument = {
          signatureHelp = {
            dynamicRegistration = false,
          },
        },
      }
    ),

    init_options = {
      bundles = jdtls_bundles(),
    },

    settings = {
      java = {
        signatureHelp = { enabled = true },
        -- You can add java settings here later if you want
      },
    },

    on_attach = function(client, bufnr)
      -- If semantic tokens cause issues in NvChad themes/perf:
      client.server_capabilities.semanticTokensProvider = nil

      -- Hook jdtls <-> nvim-dap
      jdtls.setup_dap({ hotcodereplace = "auto" })
      pcall(function()
        require("jdtls.dap").setup_dap_main_class_configs()
      end)
      -- Keymaps
      java_keymaps(bufnr)
    end,
  }

  jdtls.start_or_attach(config)
end

return M
